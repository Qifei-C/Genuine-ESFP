import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.integrate import solve_ivp
from scipy.spatial.transform import Rotation as R
import sys

# --- Parameters ---
N_JOINTS = 3
INITIAL_ANGLES = np.zeros(N_JOINTS)
# Start joint 1 slightly above limit to avoid immediate trigger if using old events
# INITIAL_ANGLES = np.array([0.0, np.deg2rad(0.1), 0.0, 0.0])
INITIAL_ANGULAR_VELOCITIES = np.zeros(N_JOINTS)
INITIAL_CONDITIONS = np.concatenate([INITIAL_ANGLES, INITIAL_ANGULAR_VELOCITIES])
ANGULAR_ACCELERATIONS = np.array([0.5, 1.0, -0.8]) # Base accelerations
LINK_LENGTHS = np.array([1, 1, 0.3])

ANGLE_LIMITS_DEG = [
    (-90, 90), (0, 150), (-90, 90)
]
ANGLE_LIMITS_RAD = [(np.deg2rad(lim[0]), np.deg2rad(lim[1])) for lim in ANGLE_LIMITS_DEG]

T_START = 0
T_END = 5
N_FRAMES = 300 # Increase frames for smoother animation with bounces
TIME = np.linspace(T_START, T_END, N_FRAMES)

# --- Limit Interaction Parameters (Tune these!) ---
LIMIT_STIFFNESS = 500.0  # Spring constant (higher = harder limit)
LIMIT_DAMPING = 15.0     # Damping factor (controls oscillation/bounce)

# --- Modified Dynamics Function ---
def arm_dynamics_limit_interaction(t, y, base_acc, n_joints, limits_rad, k, b):
    """
    Arm dynamics including spring-damper interaction at joint limits.
    Assumes unit inertia for simplicity (torque directly becomes angular acceleration).
    """
    angles = y[:n_joints]
    velocities = y[n_joints:]
    dydt = np.zeros_like(y)

    # 1. Calculate velocity changes based on angles
    dydt[:n_joints] = velocities

    # 2. Calculate acceleration changes
    limit_torques = np.zeros(n_joints) # Torques generated by limit interaction
    for i in range(n_joints):
        angle = angles[i]
        velocity = velocities[i]
        lower_lim, upper_lim = limits_rad[i]

        penetration = 0.0
        # Check lower limit
        if angle < lower_lim:
            penetration = lower_lim - angle # Positive penetration distance
            spring_torque = k * penetration   # Positive torque (pushes angle up)
            damping_torque = -b * velocity    # Opposes velocity
            limit_torques[i] = spring_torque + damping_torque
            # Optional: Prevent damping from pulling further into limit if velocity is already positive
            if velocity > 0:
                 limit_torques[i] = max(0, spring_torque) + damping_torque # Ensure net force pushes out

        # Check upper limit
        elif angle > upper_lim:
            penetration = angle - upper_lim # Positive penetration distance
            spring_torque = -k * penetration  # Negative torque (pushes angle down)
            damping_torque = -b * velocity    # Opposes velocity
            limit_torques[i] = spring_torque + damping_torque
             # Optional: Prevent damping from pulling further into limit if velocity is already negative
            if velocity < 0:
                 limit_torques[i] = min(0, spring_torque) + damping_torque # Ensure net force pushes out


    # Add base acceleration and limit interaction torques
    # Assuming unit inertia: acceleration = torque
    dydt[n_joints:] = base_acc + limit_torques

    return dydt

# --- Kinematics (No change needed) ---
def calculate_joint_positions(angles, link_lengths):
    n = len(angles)
    positions = np.zeros((n + 1, 3))
    current_position = np.array([0.0, 0.0, 0.0])
    positions[0] = current_position
    current_rotation = R.identity()
    for i in range(n):
        joint_rotation = R.from_euler('z', angles[i], degrees=False)
        current_rotation = current_rotation * joint_rotation
        link_vector_local = np.array([link_lengths[i], 0.0, 0.0])
        current_position = current_position + current_rotation.apply(link_vector_local)
        positions[i+1] = current_position
    return positions

# --- Event Definitions (Optional: Non-Terminal Logging) ---
# You can keep these with terminal=False if you want to log limit hits
events = []
def create_limit_event_log(joint_index, limit_value, is_upper_limit):
    # ... (same event function logic as before) ...
    event_func = event_upper if is_upper_limit else event_lower
    event_func.terminal = False # **** SET TO FALSE ****
    event_func.direction = -1 if is_upper_limit else 1
    return event_func

# for i in range(N_JOINTS):
#     lower_limit_event = create_limit_event_log(i, ANGLE_LIMITS_RAD[i][0], False)
#     events.append(lower_limit_event)
#     upper_limit_event = create_limit_event_log(i, ANGLE_LIMITS_RAD[i][1], True)
#     events.append(upper_limit_event)
# OR simply set events=None if not needed for logging

# --- Solve ODE ---
print("Starting ODE integration with limit interaction...")
sol = solve_ivp(
    fun=arm_dynamics_limit_interaction,
    t_span=[T_START, T_END],
    y0=INITIAL_CONDITIONS,
    method='RK45', # Start with RK45, may need 'Radau' or 'BDF' if stiff
    t_eval=TIME,
    args=(ANGULAR_ACCELERATIONS, N_JOINTS, ANGLE_LIMITS_RAD, LIMIT_STIFFNESS, LIMIT_DAMPING),
    # events=events, # Optional: include non-terminal events for logging
    dense_output=True,
    # max_step=0.01 # Optional: Limit max step size if solver struggles
)
print("Integration finished.")

# --- Extract Results ---
solution_time = sol.t
solution_y = sol.y.T

angles = solution_y[:, :N_JOINTS]
angular_velocities = solution_y[:, N_JOINTS:]

print(f"Simulation ran until t = {solution_time[-1]:.3f} seconds.")
print(f"Number of time steps evaluated: {len(solution_time)}")
print(f"Solver status: {sol.status}") # Should be 0 if completed successfully
print(f"Solver message: {sol.message}")

# --- Calculate Positions ---
all_positions = []
for i in range(len(solution_time)):
    positions = calculate_joint_positions(angles[i], LINK_LENGTHS)
    all_positions.append(positions)
all_positions = np.array(all_positions)

# --- Animation Setup (No change needed, but check axis limits) ---
print("Setting up animation...")
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

max_range = 0
if all_positions.size > 0:
    min_coords = np.min(all_positions.reshape(-1, 3), axis=0)
    max_coords = np.max(all_positions.reshape(-1, 3), axis=0)
    center = (max_coords + min_coords) / 2.0
    max_range = np.max(max_coords - min_coords)
    plot_limit = max_range * 0.6 + 0.5
else:
    print("Warning: No positions generated by simulation.")
    center = np.zeros(3)
    plot_limit = sum(LINK_LENGTHS) * 0.6 + 0.5

ax.set_xlim([center[0] - plot_limit, center[0] + plot_limit])
ax.set_ylim([center[1] - plot_limit, center[1] + plot_limit])
ax.set_zlim([center[2] - plot_limit, center[2] + plot_limit])
ax.set_xlabel('X (m)')
ax.set_ylabel('Y (m)')
ax.set_zlabel('Z (m)')
ax.set_aspect('equal', adjustable='box')
title = ax.set_title('3D Arm Pose (Spring-Damper Limits)')
points, = ax.plot([], [], [], 'ro', markersize=8, label='Joints')
lines = [ax.plot([], [], [], lw=3, c='royalblue')[0] for _ in range(N_JOINTS)]

def update(frame):
    if frame >= len(all_positions):
        return [points] + lines + [title]
    current_positions = all_positions[frame]
    points.set_data(current_positions[:, 0], current_positions[:, 1])
    points.set_3d_properties(current_positions[:, 2])
    for i in range(N_JOINTS):
        x_data = [current_positions[i, 0], current_positions[i+1, 0]]
        y_data = [current_positions[i, 1], current_positions[i+1, 1]]
        z_data = [current_positions[i, 2], current_positions[i+1, 2]]
        lines[i].set_data(x_data, y_data)
        lines[i].set_3d_properties(z_data)
    title.set_text(f'Arm Pose (Time: {solution_time[frame]:.2f}s, Limits: k={LIMIT_STIFFNESS}, b={LIMIT_DAMPING})')
    return [points] + lines + [title]

ani = FuncAnimation(fig, update, frames=len(solution_time),
                    interval=max(10, int(1000 * (T_END / N_FRAMES))),
                    blit=False)
ax.legend()
plt.tight_layout()

# --- Optional: Print Event Info (if non-terminal events were used) ---
# ... (Use the robust event printing code from before if needed) ...

# --- Show Plot ---
try:
    # Save as GIF using pillow
    ani.save('animation_pillow.gif', writer='pillow')

    # Save as GIF using imagemagick (ensure imagemagick is installed and in PATH)
    ani.save('animation_imagemagick.gif', writer='imagemagick')

    plt.show()
    print("Animation window opened.")
except Exception as e:
    print(f"\nCould not display animation window: {e}")
    # ... (saving suggestion) ...